import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as t,a,b as s,o as n}from"./app-a4a-vXY8.js";const p={},o={class:"MathJax",jax:"SVG",style:{position:"relative"}},r={style:{"vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.568ex",height:"1.645ex",role:"img",focusable:"false",viewBox:"0 -705 2903 727","aria-hidden":"true"},l={class:"MathJax",jax:"SVG",style:{position:"relative"}},Q={style:{"vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.92ex",height:"1.937ex",role:"img",focusable:"false",viewBox:"0 -833.9 3942.5 855.9","aria-hidden":"true"};function c(g,e){return n(),i("div",null,[e[7]||(e[7]=t('<p>AES有多种加密方式和填充方式。</p><h1 id="加密方式" tabindex="-1"><a class="header-anchor" href="#加密方式"><span>加密方式</span></a></h1><p>分组密码加密方式主要有7种：ECB，CBC，CFB，OFB和CTR，这五种方式将在下面一一讲解。</p><h2 id="_0-初始化向量-iv" tabindex="-1"><a class="header-anchor" href="#_0-初始化向量-iv"><span>0. 初始化向量 / IV</span></a></h2><p>在讲加密模式之前首先得要了解一个概念：<strong>初始化向量 (IV)</strong></p><p>在除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。在使用同一种加密同一个密钥时不应该使用相同的IV，否则会失去一定甚至全部的安全性。如果到这里还不明白的话没关系，后面还会继续讲到。</p><h2 id="_1-电子密码本-ecb" tabindex="-1"><a class="header-anchor" href="#_1-电子密码本-ecb"><span>1. 电子密码本 / ECB</span></a></h2><figure><img src="https://pic2.zhimg.com/80/v2-37db96abc441e027e02c56a9908c8931_1440w.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',8)),a("p",null,[e[4]||(e[4]=s("这里")),a("mjx-container",o,[(n(),i("svg",r,e[0]||(e[0]=[t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mi" transform="translate(1264,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(2015,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g>',1)]))),e[1]||(e[1]=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"C"),a("mi",null,"I"),a("mi",null,"P"),a("mi",null,"H")])],-1))]),e[5]||(e[5]=s("指AES加密算法，")),a("mjx-container",l,[(n(),i("svg",Q,e[2]||(e[2]=[t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(760,0)"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mi" transform="translate(1264,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="msup" transform="translate(2015,0)"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(973.9,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g>',1)]))),e[3]||(e[3]=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"C"),a("mi",null,"I"),a("mi",null,"P"),a("msup",null,[a("mi",null,"H"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mo",null,"−"),a("mn",null,"1")])])])],-1))]),e[6]||(e[6]=s("指AES解密算法。"))]),e[8]||(e[8]=t(`<p>这个很好理解：将明文简单的按照<code>128bit</code>为一个分块进行切割，把每个分块分别进行AES加密，然后再将得到的密文简单的拼接一下即可。</p><p>注意到AES加密只能加密<code>128bit</code>的分块，那问题就产生了：<strong>如果明文的长度不是128bit的倍数，就会存在一个分块不足128bit，那如何对这个分块进行加密？</strong></p><p>别慌，你想到的问题别人早就想到了。为了解决这个问题，我们发明了一种叫做<strong>填充</strong>的东西，这将会在后面具体讲解。<strong>OFB和CTR不需要填充！</strong></p><p>ECB模式有一个显著的安全问题：如果使用相同的密钥，那么相同的明文块就会生成相同的密文块，不能很好的隐藏数据模式。这听起来没什么大事，但事实上这对数据安全是一个很大的威胁，下面这张图很明显的体现出了这个问题：</p><figure><img src="https://pic2.zhimg.com/80/v2-0adc6df353ebab3a53b8b93c003c80f5_1440w.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因此，在密码协议中不建议使用ECB模式。</p><h2 id="_2-密码块链接-cbc" tabindex="-1"><a class="header-anchor" href="#_2-密码块链接-cbc"><span>2. 密码块链接 / CBC</span></a></h2><p>在CBC中，每个明文块要先与前一个密文块进行异或后再加密，每个密文块都依赖于前面的所有明文块。</p><p>那么问题又来了：第一个明文块怎么办？</p><p>这个时候就要用到IV了。在CBC中，IV先与第一个明文块进行异或，得到第一个明文块，然后再进行后续的加密。详见下图：</p><figure><img src="https://pic2.zhimg.com/80/v2-bf344b53b742b6629dac81ed27892585_1440w.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个方法看起来很不错，但有一个缺点：加密过程是串行的，不能并行化，速度比较慢，但是解密可以并行。另外，如果密文的某一位被修改了，只会使这个密文块所对应的明文块完全改变并且改变下一个明文块的对应位，安全性仍然有一定的欠缺。</p><h2 id="_3-密文反馈-cfb" tabindex="-1"><a class="header-anchor" href="#_3-密文反馈-cfb"><span>3. 密文反馈 / CFB</span></a></h2><p>CFB的加密跟解密过程几乎完全相同，<strong>注意它在解密过程中使用的是AES加密而不是AES解密</strong></p><p>接着我们细细来看下它的过程：</p><figure><img src="https://pic3.zhimg.com/80/v2-ffe806528816ad84b24293162d241b46_1440w.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>CFB模式可以说是5个模式里最为特殊的一个，<strong>它不仅使用了数据块，还另外引入了一个它所独有的“数据段”的概念</strong>。在其他的加密方式中，明文和密文都是以数据块进行“打包”来加密的，而在CFB中却是以“数据段”为单位进行操作。</p><p>我们来细细看看它的过程：</p><p>首先是将输入的IV作为第一个输入块进行AES加密，得到第一个输出块<code>OUTPUT BLOCK1</code>。仔细看图，我们发现，<strong>在这个输出块中，只取了它的前s bit的数据与第一个明文段进行异或操作</strong>。因此我们可以知道：<strong>数据段的长度一定会小于等于数据块的长度</strong>。常用的数据段长度有：<code>1bit</code>, <code>8bits</code> 和<code>128bits</code>，因此CFB也分为CFB1、CFB8和CFB128，再分别跟三种AES算法组合，CFB加密总共有9种。</p><p>我们继续往下看，在<code>OUTPUT BLOCK1</code>中只取了前<code>s bits</code>与第一个明文段进行异或得到了第一个密文段，接着第一个密文段变成了第二个加密块的输入块的后<code>S bits</code>，那么问题来了：<strong>第二个块和后面的所有块的前<code>(b-s)bits</code>是从哪里来的？</strong></p><p>我们注意到，在前一个加密块得到的密文块中，舍弃掉了后<code>(b-s)bits</code>，<strong>而这<code>(b-s)bits</code>就变成了后一个加密块的输入中的前<code>(b-s)bits</code></strong>。</p><p>接下来又有一个十分反人类的问题：为什么在CFB的解密过程中使用的是加密算法而非解密算法？</p><p>这个问题看起来十分反常识，但实际上很好解释：密文段是由明文段与另一端信息进行异或得到的，那么也得要由原来的密文段异或上同样的一段信息才可以还原原来的明文段，而原来的那一段信息是由AES加密得到的，那么在解密过程中也要同样的进行加密才能算出这段内容以进行解密。</p><h2 id="_4-输出反馈-ofb" tabindex="-1"><a class="header-anchor" href="#_4-输出反馈-ofb"><span>4. 输出反馈 / OFB</span></a></h2><p>这个很简单，跟CFB128很相似，不同的是它是直接把输出块作为下一个块加密的输入块，具体看过程：</p><figure><img src="https://pic1.zhimg.com/80/v2-d4d9a93b8608e4a8326f84d9b5546f0c_1440w.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_5-计数器模式-ctr" tabindex="-1"><a class="header-anchor" href="#_5-计数器模式-ctr"><span>5. 计数器模式 / CTR</span></a></h2><p>如下图</p><figure><img src="https://pic2.zhimg.com/80/v2-edac15a9dfe3b2b18630014f31f1fd45_1440w.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>COUNTER</code>是整个CTR模式的核心所在。它是由IV经过一定的规则之后生成的一段数据，长度与数据块的长度相等。接着我们要选定一个数m，这个m是用于确定计数器中累加部分的大小的，通常取块大小的一半，块大小是奇数就四舍五入（当然对于AES并没有这个问题）。初始的计数器<code>COUNTER1</code>是<strong>长度固定的任意一个随机字节序列</strong>，而不是像想象中那样一段随机数后面跟着一段0。</p><p>现在我们假设块大小b=8bits,m=5bits (<strong>这里只是为了便于举例才取8bits和5bits，在AES-CTR中通常是取16bytes和8bytes</strong>)，我们用<code>*</code>表示随机值部分，初始计数器为<code>***11110</code>，那么最终计数器就是这样的：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>***11110</span></span>
<span class="line"><span>***11111</span></span>
<span class="line"><span>***00000</span></span>
<span class="line"><span>***00001</span></span>
<span class="line"><span>***00002</span></span>
<span class="line"><span>......</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，随机部分内容不变，其他部分每次+1，如果超出了范围就从0开始重新来。</p><blockquote><p>网上很多都是说计数器是由nonce和counter组成，nonce和counter拼接组成计数器。这种说法其实本质上还是一样的，nonce就相当于这里counter的随机数部分，只不过我这里把两个合在一块讲了。</p></blockquote><h1 id="填充" tabindex="-1"><a class="header-anchor" href="#填充"><span>填充</span></a></h1><p>填充有六种：NoPadding, PKCS#5, PKCS#7, ISO 10126, ANSI X9.23和ZerosPadding</p><h2 id="nopadding" tabindex="-1"><a class="header-anchor" href="#nopadding"><span>NoPadding</span></a></h2><p>顾名思义，就是不填充。缺点就是只能加密长为128bits倍数的信息，一般不会使用</p><h2 id="pkcs-7-pkcs-5" tabindex="-1"><a class="header-anchor" href="#pkcs-7-pkcs-5"><span>PKCS#7 &amp; PKCS#5</span></a></h2><p>缺几个字节就填几个缺的字节数。</p><p>例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>... | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意：如果当前数据已经是128bits的倍数了也得要填充，否则无法解密。</p><p>对于AES来说PKCS5Padding和PKCS7Padding是完全一样的，不同在于PKCS5限定了块大小为8bytes而PKCS7没有限定。因此对于AES来说两者完全相同，但是对于Rijndael就不一样了。AES是Rijndael在块大小为8bytes时的特例，对于使用其他信息块大小的Rijndael算法只能使用PKCS7</p><blockquote><p>2020.6.6更新：PKCS5的块大小是8bytes而AES的块大小是16bytes，所以实际上在AES加密中是不能使用PKCS5的，我们通常说的PKCS5和PKCS7就是同一个东西</p><p>（感谢知乎评论区提醒）</p></blockquote><h2 id="zerospadding" tabindex="-1"><a class="header-anchor" href="#zerospadding"><span>ZerosPadding</span></a></h2><p>全部填充<code>0x00</code>，无论缺多少全部填充<code>0x00</code>，已经是128bits倍数仍要填充</p><p>例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 00 |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="iso-10126" tabindex="-1"><a class="header-anchor" href="#iso-10126"><span>ISO 10126</span></a></h2><p>最后一个字节是填充的字节数（包括最后一字节），其他全部填随机数</p><p>例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>... | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="ansi-x9-23" tabindex="-1"><a class="header-anchor" href="#ansi-x9-23"><span>ANSI X9.23</span></a></h2><p>跟ISO 10126很像，只不过ANSI X9.23其他字节填的都是0而不是随机数</p><p>例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><blockquote><p>参考资料：</p><p><a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf" target="_blank" rel="noopener noreferrer">NIST Special Publication 800-38A, 2001 Edition</a></p></blockquote>`,59))])}const T=d(p,[["render",c]]),b=JSON.parse('{"path":"/posts/Crypto/aes-mode-padding.html","title":"AES加密(3)：AES加密模式与填充","lang":"zh-CN","frontmatter":{"title":"AES加密(3)：AES加密模式与填充","date":"2020-04-06T09:26:00.000Z","mathjax":true,"tag":["加密"],"category":["Cryptography","Symmetric"],"description":"AES有多种加密方式和填充方式。 加密方式 分组密码加密方式主要有7种：ECB，CBC，CFB，OFB和CTR，这五种方式将在下面一一讲解。 0. 初始化向量 / IV 在讲加密模式之前首先得要了解一个概念：初始化向量 (IV) 在除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。在使用同一种加密同一个密钥时不应该使用相同的IV，否则会...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AES加密(3)：AES加密模式与填充\\",\\"image\\":[\\"https://pic2.zhimg.com/80/v2-37db96abc441e027e02c56a9908c8931_1440w.jpg\\",\\"https://pic2.zhimg.com/80/v2-0adc6df353ebab3a53b8b93c003c80f5_1440w.jpg\\",\\"https://pic2.zhimg.com/80/v2-bf344b53b742b6629dac81ed27892585_1440w.jpg\\",\\"https://pic3.zhimg.com/80/v2-ffe806528816ad84b24293162d241b46_1440w.jpg\\",\\"https://pic1.zhimg.com/80/v2-d4d9a93b8608e4a8326f84d9b5546f0c_1440w.jpg\\",\\"https://pic2.zhimg.com/80/v2-edac15a9dfe3b2b18630014f31f1fd45_1440w.jpg\\"],\\"datePublished\\":\\"2020-04-06T09:26:00.000Z\\",\\"dateModified\\":\\"2025-06-07T14:22:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Renatus Madrigal\\",\\"url\\":\\"https://www.listener1379.top/\\"}]}"],["meta",{"property":"og:url","content":"https://www.listener1379.top/posts/Crypto/aes-mode-padding.html"}],["meta",{"property":"og:site_name","content":"Arendelle Royal Library"}],["meta",{"property":"og:title","content":"AES加密(3)：AES加密模式与填充"}],["meta",{"property":"og:description","content":"AES有多种加密方式和填充方式。 加密方式 分组密码加密方式主要有7种：ECB，CBC，CFB，OFB和CTR，这五种方式将在下面一一讲解。 0. 初始化向量 / IV 在讲加密模式之前首先得要了解一个概念：初始化向量 (IV) 在除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。在使用同一种加密同一个密钥时不应该使用相同的IV，否则会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic2.zhimg.com/80/v2-37db96abc441e027e02c56a9908c8931_1440w.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-07T14:22:22.000Z"}],["meta",{"property":"article:tag","content":"加密"}],["meta",{"property":"article:published_time","content":"2020-04-06T09:26:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-07T14:22:22.000Z"}]]},"git":{"createdTime":1749306142000,"updatedTime":1749306142000,"contributors":[{"name":"arendellian13","username":"arendellian13","email":"listener1381@outlook.com","commits":1,"url":"https://github.com/arendellian13"}]},"readingTime":{"minutes":7.12,"words":2136},"filePathRelative":"posts/Crypto/aes-mode-padding.md","excerpt":"<p>AES有多种加密方式和填充方式。</p>\\n<h1>加密方式</h1>\\n<p>分组密码加密方式主要有7种：ECB，CBC，CFB，OFB和CTR，这五种方式将在下面一一讲解。</p>\\n<h2>0. 初始化向量 / IV</h2>\\n<p>在讲加密模式之前首先得要了解一个概念：<strong>初始化向量 (IV)</strong></p>\\n<p>在除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。在使用同一种加密同一个密钥时不应该使用相同的IV，否则会失去一定甚至全部的安全性。如果到这里还不明白的话没关系，后面还会继续讲到。</p>\\n<h2>1. 电子密码本 / ECB</h2>","autoDesc":true}');export{T as comp,b as data};
