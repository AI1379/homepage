import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as o,f as c,d,b as a,o as i}from"./app-CQfBVnSx.js";const n={};function l(p,e){return i(),t("div",null,[e[0]||(e[0]=o("p",null,[a("这里是"),o("a",{href:"https://github.com/AI1379/tiny-cobalt",target:"_blank",rel:"noopener noreferrer"},"Tiny Cobalt"),a("的开发日志。尽量持续更新。")],-1)),c("more"),e[1]||(e[1]=d('<h2 id="初期工作-框架的搭建" tabindex="-1"><a class="header-anchor" href="#初期工作-框架的搭建"><span>初期工作：框架的搭建</span></a></h2><p>两年前和 <a href="https://github.com/AndyShen2006" target="_blank" rel="noopener noreferrer">AndyShen</a> 最初决定写自己的编译器的时候，打算的技术方案是 CMake 作为构建系统，标准定在 C++17 。24年12月初的时候我决定重新开工，此时各大编译器对于 C++20 的支持已经逐渐完善了，此外 <a href="https://xmake.io" target="_blank" rel="noopener noreferrer">xmake</a> 构建系统也已经比当年更加完善，因此重新启动 Cobalt 项目的时候，我决定采用 xmake 作为编译系统。这带来的一大好处是便捷的包管理，另一个好处是可以避免复杂的 cmake 脚本，可以注意力集中在代码上而不用折腾太多依赖。</p><p>最开始，我们打算基于 <code>std::variant</code> 作为运行时多态的实现，此外也引入了微软的 <a href="https://github.com/microsoft/proxy" target="_blank" rel="noopener noreferrer"><code>proxy</code></a> 库作为备用方案，目的是为了尝试着探索 C++ 传统的继承+虚函数方案以外的其他多态方案。然而，在实现的过程中，我们发现 <code>std::variant</code> 并不能完全实现我们需要的多态，此外它与 <code>proxy</code> 的兼容性也一般。因此，我们决定全面改用 <code>proxy</code> 。在 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/include/Common/Utility.h" target="_blank" rel="noopener noreferrer">Utility.h</a> 中可以看到一些早期代码的残留。后来在开发过程中发现了 <code>proxy</code> 方案的一些问题，此处暂且不表。</p><p>在架构上，我们采用了传统的 <code>Lexer/Parser -&gt; Semantic Analyzer -&gt; Backend</code> 的方案，词法分析和语法分析使用 <code>flex</code> 和 <code>bison</code> 生成，后端则直接使用 <code>LLVM</code> 作为后端。目前也有计划将手工实现词法分析和语法分析。每一部分之间都是解耦的，以便模块化。测试方面，采用 <code>googletest</code> 作为测试框架。</p><h2 id="cobalt-的语法设计" tabindex="-1"><a class="header-anchor" href="#cobalt-的语法设计"><span>Cobalt 的语法设计</span></a></h2><p>总的来讲，Cobalt 的语法设计是类似 C++ 的，此外也有可能加入一些 Haskell 和 Rust 的语法。Cobalt 与 C++ 的语法差别主要是在类型系统上。我们抛弃了 C 中传统的指针和数组定义方式，转而使用类似 C++ 模板的方式来实现，一方面是为了编译器相对好写一些，另一方面是为了可读性。</p><p>此外，我们还要求类型以大写字母开头，具体原因是为了便于语法分析。</p><p>另外，在类型转换方面，我们的设计也是 C++ 的方案，而抛弃了 C 中的语法。</p><h2 id="ast-的设计" tabindex="-1"><a class="header-anchor" href="#ast-的设计"><span>AST 的设计</span></a></h2><h3 id="基础结构" tabindex="-1"><a class="header-anchor" href="#基础结构"><span>基础结构</span></a></h3><p>这部分的代码主要在 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/include/AST/ASTNode.h" target="_blank" rel="noopener noreferrer">ASTNode.h</a> 和 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/include/AST/ASTVisitor.h" target="_blank" rel="noopener noreferrer">ASTVisitor.h</a></p><p>首先我们参考 <code>libstdc++</code> 的源码实现了 C++23 的 <code>std::generator</code>，然后通过 <code>co_yield</code> 的方式把树的遍历抽象出来，以便 <code>ASTVisitor</code> 的实现。同时我们也引入了 <code>nlohmann/json</code> 库，以便实现 AST 的序列化，便于调试。</p><p>此外，我们还实现了一个 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/include/AST/ASTBuilder.h" target="_blank" rel="noopener noreferrer"><code>ASTBuilder</code></a>，使得我们可以在 C++ 代码中直接以一种类似 <code>json</code> 的格式构建 AST 。</p><h3 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h3><p>这一部分比较机械化。我们设计了以下 AST 节点：</p><ul><li><code>ASTRootNode</code></li><li><code>ExprNode</code><ul><li><code>ConstExprNode</code></li><li><code>VariableNode</code></li><li><code>BinaryNode</code></li><li><code>UnaryNode</code></li><li><code>MultiaryNode</code></li><li><code>CastNode</code></li><li><code>ConditionNode</code></li><li><code>MemberNode</code></li></ul></li><li><code>StmtNode</code><ul><li><code>IfNode</code></li><li><code>WhileNode</code></li><li><code>ForNode</code></li><li><code>ReturnNode</code></li><li><code>BlockNode</code></li><li><code>BreakNode</code></li><li><code>ContinueNode</code></li><li><code>VariableDefNode</code></li><li><code>FuncDefNode</code></li><li><code>StructDefNode</code></li><li><code>AliasDefNode</code></li><li><code>ExprStmtNode</code></li><li><code>EmptyStmtNode</code></li></ul></li><li><code>TypeNode</code><ul><li><code>SimpleTypeNode</code></li><li><code>FuncTypeNode</code></li><li><code>ComplexTypeNode</code></li></ul></li></ul><p>基本上就是照抄了 C++ 中的实现。我们为三类节点分别实现了一个对应的 <code>proxy</code> 定义了相关 API，方便后续扩展。</p><h3 id="astvisitor-和-astvisitormiddleware" tabindex="-1"><a class="header-anchor" href="#astvisitor-和-astvisitormiddleware"><span><code>ASTVisitor</code> 和 <code>ASTVisitorMiddleware</code></span></a></h3><p>这部分的代码在 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/include/AST/ASTVisitor.h" target="_blank" rel="noopener noreferrer">ASTVisitor.h</a> 中。</p><p>首先实现了一个模板 <code>BaseASTVisitor</code> ，实现了 AST 的遍历。一开始这个模板设计为一个 CRTP 的基类模板，后来改为传入一个 <code>Middleware</code> 作为模板参数，<code>Visitor</code> 负责调用。目前看来，这似乎是一个冗余设计，因此后期可能会重构。</p><p>此后定义了 <code>BaseASTVisitorMiddleware</code> ，利用 CRTP 自动生成 <code>Visitor</code> 所需要的接口；同时定义了对应的 <code>proxy</code> ，不过似乎没有用上。</p><p>在 <code>Visitor</code> 的设计中，我们定义了一个名为 <code>VisitorState</code> 的枚举，用于在中间件中方便地控制 <code>ASTVisitor</code> 的状态，实现在中间件中跳出整个遍历流程。</p><h2 id="lexerparser-的实现" tabindex="-1"><a class="header-anchor" href="#lexerparser-的实现"><span>LexerParser 的实现</span></a></h2><p>Bison 对 C++ 的支持颇为不错，相比之下 flex 对 C++ 的支持就相对较差。</p><h3 id="语法分析部分" tabindex="-1"><a class="header-anchor" href="#语法分析部分"><span>语法分析部分</span></a></h3><p>具体可见 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/src/LexerParser/Parser.yy" target="_blank" rel="noopener noreferrer">Parser.yy</a>。</p><p>在 <code>parser</code> 的实现过程中，我们遇到了早期 C++ 编译器实现时遇到的许多问题，例如模板尖括号与大于小于号的区分问题，以及嵌套模板与右移运算符的区分问题。为了区分右移运算符，我们采取了早期 C++ 编译器要求的方案，即要求嵌套模板的两个右尖括号中插入空格。而比较运算符的冲突则比较难办。</p><p>查阅 <code>clang</code> 和 <code>gcc</code> 的源码，可以发现它们将一部分的语义分析流程提前到了语法分析的时候，在建立 AST 之前就建立符号表，从而将模板与变量区分开，解决这个问题。然而，这与我们当前的设计是矛盾的。我们目前的解决方案是强制要求所有类型（除了几个基本类型）与模板都以大写字母开头，而变量和函数是小写字母开头，从而将 <code>typename</code> 与 <code>identifier</code> 在词法分析阶段就区分开来。这只是一个折中的方案，然而似乎找不到更好的解决措施。</p><p>此外，在实现逗号表达式的时候也遇到了很多 <code>Shift/Reduce Conflict</code> 和 <code>Reduce/Reduce Conflict</code>，因此在目前的代码里还不支持逗号表达式。</p><h3 id="词法分析部分" tabindex="-1"><a class="header-anchor" href="#词法分析部分"><span>词法分析部分</span></a></h3><p>这部分相对简单，参考 bison 的样例很容易实现。</p><h3 id="driver-的设计" tabindex="-1"><a class="header-anchor" href="#driver-的设计"><span>Driver 的设计</span></a></h3><p>在 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/include/LexerParser/Parser.h" target="_blank" rel="noopener noreferrer">Parser.h</a> 中我们定义了一个模板类，接受不同的 Driver 作为前端。由于 Lexer 由 flex 生成，而 flex 目前对 C++的支持相当糟糕，因此我们把这部分糟糕的代码隔离出来放在 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/src/LexerParser/YaccDriver.h" target="_blank" rel="noopener noreferrer">YaccDriver.h</a> 和 <a href="https://github.com/AI1379/tiny-cobalt/blob/main/src/LexerParser/YaccDriver.cpp" target="_blank" rel="noopener noreferrer">YaccDriver.cpp</a> 中。这里参考了 StackOverflow 上的一篇文章。</p><p>此后有计划完善这部分的设计，然后手工实现完整的词法分析与语法分析。</p><h2 id="语义分析" tabindex="-1"><a class="header-anchor" href="#语义分析"><span>语义分析</span></a></h2><p>这一部分是目前还在进行的工作，主要有以下板块。</p><h3 id="declmatcher" tabindex="-1"><a class="header-anchor" href="#declmatcher"><span><code>DeclMatcher</code></span></a></h3><p>这一部分是在词法分析中最先进行的。出于性能考虑，我们采用了 C++23 的 <code>std::flat_map</code>。由于目前标准库对其支持并不完善，因此我们自己实现了一个。</p><p>我们在 <code>DeclMatcher</code> 中维护了四个 <code>Scope</code>，分别存储不同类型的符号。</p><h3 id="typeanalyzer" tabindex="-1"><a class="header-anchor" href="#typeanalyzer"><span><code>TypeAnalyzer</code></span></a></h3><p>在完成符号匹配后，才能进行类型的分析。这一部分也还没有完全实现。</p>',41))])}const b=r(n,[["render",l]]),m=JSON.parse('{"path":"/posts/tiny-cobalt-dev.html","title":"Tiny Cobalt 开发日志","lang":"zh-CN","frontmatter":{"title":"Tiny Cobalt 开发日志","date":"2025-02-10T09:49:30.000Z","tag":["编译原理","Tiny Cobalt"],"category":["Compiler"],"description":"这里是Tiny Cobalt的开发日志。尽量持续更新。 初期工作：框架的搭建 两年前和 AndyShen 最初决定写自己的编译器的时候，打算的技术方案是 CMake 作为构建系统，标准定在 C++17 。24年12月初的时候我决定重新开工，此时各大编译器对于 C++20 的支持已经逐渐完善了，此外 xmake 构建系统也已经比当年更加完善，因此重新启动...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Tiny Cobalt 开发日志\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-02-10T09:49:30.000Z\\",\\"dateModified\\":\\"2025-06-07T14:22:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Renatus Madrigal\\",\\"url\\":\\"https://www.listener1379.top/\\"}]}"],["meta",{"property":"og:url","content":"https://www.listener1379.top/posts/tiny-cobalt-dev.html"}],["meta",{"property":"og:site_name","content":"Arendelle Royal Library"}],["meta",{"property":"og:title","content":"Tiny Cobalt 开发日志"}],["meta",{"property":"og:description","content":"这里是Tiny Cobalt的开发日志。尽量持续更新。 初期工作：框架的搭建 两年前和 AndyShen 最初决定写自己的编译器的时候，打算的技术方案是 CMake 作为构建系统，标准定在 C++17 。24年12月初的时候我决定重新开工，此时各大编译器对于 C++20 的支持已经逐渐完善了，此外 xmake 构建系统也已经比当年更加完善，因此重新启动..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-07T14:22:22.000Z"}],["meta",{"property":"article:tag","content":"Tiny Cobalt"}],["meta",{"property":"article:tag","content":"编译原理"}],["meta",{"property":"article:published_time","content":"2025-02-10T09:49:30.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-07T14:22:22.000Z"}]]},"git":{"createdTime":1749306142000,"updatedTime":1749306142000,"contributors":[{"name":"arendellian13","username":"arendellian13","email":"listener1381@outlook.com","commits":1,"url":"https://github.com/arendellian13"}]},"readingTime":{"minutes":5.74,"words":1721},"filePathRelative":"posts/tiny-cobalt-dev.md","excerpt":"<p>这里是<a href=\\"https://github.com/AI1379/tiny-cobalt\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Tiny Cobalt</a>的开发日志。尽量持续更新。</p>\\n<!--more-->\\n<h2>初期工作：框架的搭建</h2>\\n<p>两年前和 <a href=\\"https://github.com/AndyShen2006\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">AndyShen</a> 最初决定写自己的编译器的时候，打算的技术方案是 CMake 作为构建系统，标准定在 C++17 。24年12月初的时候我决定重新开工，此时各大编译器对于 C++20 的支持已经逐渐完善了，此外 <a href=\\"https://xmake.io\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">xmake</a> 构建系统也已经比当年更加完善，因此重新启动 Cobalt 项目的时候，我决定采用 xmake 作为编译系统。这带来的一大好处是便捷的包管理，另一个好处是可以避免复杂的 cmake 脚本，可以注意力集中在代码上而不用折腾太多依赖。</p>","autoDesc":true}');export{b as comp,m as data};
